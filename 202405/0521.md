# TIL (Today I Learned)

# 5월 21일 화요일

# 😃 What I Learned

## ✨오늘 진행한 내용

### 웹소켓 설계 수정

사용자가 1개의 웹소켓만 연결되도록 함

**배경**

프론트에서 웹소켓 onConnect 과정에서 방 생성이나 방 만들기를 반드시 진행하도록 구성되어있었음

때문에 무중단 배포에 의해 웹소켓이 끊어지면 다시 수립하는 과정에서 방 만들기로 새로운 방을 만들어버리는 문제가 있었음

**수정 전**

1. 프론트는 기존에 main 페이지로 이동하면 웹소켓을 모두 삭제하도록 함
2. 방 만들기, 방 입장하기 버튼에 웹소켓을 연결하도록 되어있었음

**수정 후**

1. 프론트에서 onConnect 콜백함수가 아닌 버튼에 해당하는 함수들을 연동
2. main 페이지에 들어오면 기존 웹소켓을 모두 삭제 후 새로운 웹소켓을 연결하도록 함

**결과**

사용자는 main 페이지에 들어와야 메인 플로우를 시작할 수 있음으로, 웹소켓이 중복으로 연결되는 문제를 해결

무중단 배포 시 웹소켓 재수립이 정상적으로 됨

**문제점**

만약 새로고침을 연타하면 웹소켓을 계속 끊고 새로 연결하는 문제가 있음.. (서버 리소스 적으로 매우 좋지 않음)

이는 프로젝트 기간에서 해결하지 못함

⇒ 어떻게 하면 해결할 수 있을까?

- 새로고침 이벤트에는 웹소켓 재연결 하지 않도록 프론트에서 지정
- 프론트에서 웹소켓이 필요한 페이지를 SPA로 따로 빼서 최상위 페이지인 app 페이지가 처음 로딩될 때 웹소켓 연결을 수립하도록 해도 됨

## 프로젝트

- [ ]  개인적으로 수정할 내용
    - [ ]  **레디스에 유저당 1개의 방, 1개의 상태만 저장해야 한다. → 불필요한 데이터 저장 방지**
        - [ ]  redis에 TTL을 주어서 관리할 수 있지만 이로는 부족하다 (이것도 설정해줘야함. 현재 안되어있는 것 같음)
        - [ ]  유저가 방을 또 만들려고 하면 2가지 중 하나를 선택하게 해야 한다
            1. **이미 만들어진 방에서 진행되는 플로우가 제대로 진행되고 있는 것인지 확인하고, 아니면 방 생성 요청 로직을 거부한다.**
                - 이 경우는 사실 같은 유저 아이디로 중복 로그인이 허용되기 때문에 생기는 문제이기도 하다
                - 클라이언트 단에서 중복 로그인 자체를 막거나 온라인 게임처럼 이미 진행중인 플로우가 있다면 다시 돌아갈 수 있도록 해야 하나, 이 기능은 회의 과정에서 구현하지 않기로 합의가 되어있다.
                - 또한 문제 풀이가 정상적으로 진행중인지, 아닌지를 판단할 로직이 필요하다
            2. **무조건 나중에 만들어진 방이 사용자가 의도한 작업이라고 판단하여 기존 방 정보를 삭제한다. (선택)**
                - 심플하다
                - 현재 프로젝트는 메인 플로우 중에 사용자가 나가면 어자피 비정상 종료로 인식한다.
                - 따라서 이 방법이 현 프로젝트에서는 더 적절한 방법이다.
    - [ ]  즉, 방을 만들거나 입장하는 과정에서 현 유저가 이미 방에 들어가있다면 기존에 들어있다고 되어있는 방을 삭제하고, 새로운 방을 만들거나 입장해야 한다
        - [ ]  여기서 주의할 점은 방을 만드는 것 뿐만 아니라 방에 들어가는 로직에도 이를 확인해야함을 잊지 말자.
    - [ ]  **레디스 설계**
        - [ ]  **유저 id → 방 id**
        - [ ]  방 id → 방정보 ~~& **현재 상태**~~

- 왜 레디스?
    - 사용자의 “상태”
    - 지속적으로 관리할 데이터가 아님
    - TTL로 지속적으로 삭제할 수 있음

### +a)

- 도중에 유저가 나갔을 때 다시 들어오는 기능을 구현해야 한다면 어떻게 해야할까?
    - 유저의 문제 풀이 상태를 기억해주어야 한다.
- 그러면 어떤 정보들을 기록/확인해야할까?
    - 상태 정보
        - 방 상태 : 정상진행중 (방 생성중, 문제 풀이중, 회고 작성 중 모두 포함) / 비정상 종료
    - **포기하기**
        - 프론트에서 메인 플로우 중에서 비정상적으로 나가면 포기하기 api를 보내주어야 한다. ~~(웹소켓 연결이 끊어지면 포기하기 로직을 구동하는 방법은 외부요인에 의해 웹소켓 연결 끊김 or 무중단 배포 과정에서 발생할 수 있음으로 불가)~~
        - 포기하기
    - **비 정상 종료**
        - 문제 읽기, 문제 풀이, 회고 작성 과정에서 사용자가 창을 꺼버린 경우
        - 만약 창이 꺼지는게 아니고 연결이 안되거나, 서버 에러로 인해 워크 플로우가 제대로 진행이 되지 않았다면? 서버에서 내부적인 에러가 터진다면 모두 비정상 종료로 바꿔야 하는가? → **판단 기준이 매우 애매함**

### [Call by Value vs Call by Reference in JAVA](https://www.notion.so/Call-by-Value-vs-Call-by-Reference-in-JAVA-bcd4cf5837404459ae3fa90fb2875ea7?pvs=21)

## ✨내일 진행할 내용

- [ ]  이번 프로젝트 회고 작성
- [ ]  포트폴리오 작성
    - [ ]  urturn
    - [ ]  flowermari

- [ ]  리팩토링
    - [ ]  소나큐브 리팩토링
        - [ ]  리팩토링 브랜치 따로 파서 그 브랜치 기준으로 소나큐브 새로 만들어서 비교
    - [ ]  비정상 종료 히스토리 반환 안하도록 수정
    - [ ]  커밋 메세지 나 아닌 유저 반환되도록
    - [ ]  사용자 권한 깊게 파보기
    - [ ]  그라파나 모니터링 데이터 내용 확인해보기
    - [ ]  채점 서버 모니터링 확대
    - [ ]  redis
        - [ ]  redis cache 사용법 & 원리
        - [ ]  레디스에 현재 유저 들어있는 방 확인 로직 추가

- [ ]  공부
    - [ ]  웹소켓 ~ 외부 메세지 브로커

# 😜 Today’s Small Happiness

# 🧐 Let’s Think About It

- 웹소켓이 들어가는 로직을 별도의 서버로 빼서 관리해야 할까..?
- stomp 내부 메세지 브로커 대신 외부 브로커를 사용해야할까?

# 🙀 Got Stuck..