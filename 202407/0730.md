# TIL (Today I Learned)

# 7월 30일 화요일

# 😃 What I Learned

## ✨오늘 진행한 내용

- [x]  스터디 (3시간)
- [x]  채용 공고 확인
- [x]  우아한 형제들 기술 블로그 공부하기 (1시간)
    
    ### https://techblog.woowahan.com/2527/
    
    Java의 Enum은 클래스이다!
    
    **가장 실감했던 장점은 문맥(Context)을 담는다는 것!**
    
    A라는 상황에서 "a"와 B라는 상황에서 "a"는 똑같은 문자열 "a"지만 전혀 다른 의미.
    
    문자열은 이를 표현할 수 없지만, **Enum은 이를 표현할 수 있었음**.
    
    이로 인해 실행되는 코드를 이해하기 위해 **추가로 무언가를 찾아보는 행위를 최소화**.
    
    자주 변경해야 한다면 Enum이 아닌 관리자 페이지를 이용하는 것이 더 좋을 수 있음
    
    1. **데이터들 간의 연관관계 표현 (1, true, “OK”)**
    2. **상태와 행위를 한곳에서 관리 (method, function)**
    3. **데이터 그룹관리 ( `CARD( “카드”, Arrays.asList( ”KakaoPay”, “NaverPay”, …))` )**
        - 원하는 페이 방법을 찾는 메서드를 함께 관리할 수 있음 (클래스니까!)
        - **`CARD( “카드”, Arrays.asList(  PayType.KAKAO_PAY, PayType.NAVER_PAY, …))` 이러한 방식으로 문자열이 아닌 추가적인 Enum으로 확장시킬 수 있음!**
    4. **관리 주체를 DB에서 객체로**
    
    ### https://techblog.woowahan.com/2559/
    
    - [ ]  CHAR vs VARCHAR
        - MySQL은 **CHAR와 VARCHAR 모두 PAD 추가 방식으로 비교**한다.
        - PostgreSQL은 CHAR를 저장할 때, **PAD를 추가하는 방식이 아니라 제거하는 방식**으로 저장한다.
            - 그 결과, 저장된 CHAR를 기준으로 보면 PADDING을 사용한 방식과 같은 결과를 내놓는다.
            - **VARCHAR에는 PAD를 제거하는 방식을 사용하지 않음**
        - 타입을 정의하지 않은 CHAR의 비교에 대해서 PAD를 사용할지 말지는 DB마다 다를 수 있다.
        - PADDING 방식의 원인은 CHAR 타입을 저장하는 방식과 관련이 있는 것으로 추측된다
    - [ ]  = 과 LIKE 차이
        - MySQL에서 = 비교는 오른쪽 패딩 추가를 함 (트레일링 스페이스 무시)
        - 이에 비해 LIKE는 원래 문자열 패턴 매칭시 사용하며, 트레일링 스페이스를 무시하지 않고 그대로 비교함으로 뒷 공백이 추가되면 다른 값으로 인식
    - [ ]  https://techblog.woowahan.com/17386/
    - [ ]  https://techblog.woowahan.com/12903

- [x]  데이터 중심 어플리케이션 설계 5장 : 복제 마무리 (1시간)
    - [ ]  동기식 vs 비동기식 복제
    - [ ]  팔로워 장애 → 따라잡기 복구
    - [ ]  리더 장애 → 장애 복구 + 예전 리더 복구시 팔로워 변경여부 인지
    - [ ]  복제 로그 (구문 기반 복사, 쓰기 전 로그 배송, 논리적 로그 복제), 트리거 기반 복제
    - [ ]  복제 지연
        - [ ]  쓰기 후 읽기 일관성 (자신이 쓴 내용 읽기)
        - [ ]  단조 읽기 (특정 사용자 읽기가 항상 동일한 복제 서버에서 수행 되도록 함)
        - [ ]  일관된 순서로 읽기 (파티셔닝 데이터베이스 문제)
    - [ ]  다중 리더 복제
        - [ ]  다중 데이터베이스 운영
        - [ ]  오프라인 클라이언트 (디바이스)
    - [ ]  협업 편집 등의 쓰기 충돌
        - [ ]  충돌 감지 (동기 & 비동기)
        - [ ]  충돌 회피 (특정 사용자를 특정 데이터 센터로 라우팅하여 쓰기/읽기 보장)
        - [ ]  일관된 상태 수렴 (쓰기에 ID 부여 등)
        - [ ]  사용자 정의 충돌 해소 로직 (맞춤형 코드 에러 발생 가능성)
    - [ ]  다중 리더 토폴로지 (원형, 별, 전체)
        - [ ]  메세지 추월 정렬을 위한 버전 벡터 기법
    - [ ]  리더 없는 복제
    - [ ]  읽기 복구 vs 안티 엔트로피 (읽기 발생시 vs 백그라운드 지속적으로 누락 데이터 서버 복사)
    - [ ]  정족수 (엄격한 정족수 vs 느슨한 정족수)
        - [ ]  한계
    - [ ]  동시 쓰기 감지
    - [ ]  LWW (최종 쓰기 승리)
    - [ ]  이전 발생 관계와 동시성 (동시성 : 물리적 시간이 중요하지 않음. 서로 발생했는지 알 수 없다면 동시에 발생한 것임)
        - [ ]  이전 발생 관계 파악하기
        - [ ]  형제값 병합
    - [ ]  버전 벡터 vs 벡터 시계 (묘하게 다름)
- [ ]  데이터 중심 어플리케이션 설계 6장 : 파티셔닝
    - [ ]  키-값 데이터 파티셔닝 (핫스팟, 키 범위 기준, 키 해시값 기준 파티셔닝)
    - [ ]  쏠린 작업부하와 핫스팟 완화
    - [ ]  파티셔닝 & 세컨더리 인덱스
        - [ ]  문서 기준 인덱스 파티셔닝 : 로컬 인덱스
        - [ ]  용어 기준 인덱스 파티셔닝 : 글로벌 인덱스

### 공부

- [ ]  싱글톤의 단점
- [ ]  왜 스프링은 싱글톤으로 관리?

### 면접 끝나고 할 것

- [ ]  https://github.com/squad-b/work-assistant-api 코드 뜯어보는중
- [ ]  데이터 중심 어플리케이션 설계 구매 완료 → 읽어보기
    - [ ]  카카오 **Zero-ETL** : [https://careers.kakao.com/jobs/P-13629?skillSet=&part=TECHNOLOGY&company=KAKAO&keyword=&employeeType=&page=1](https://careers.kakao.com/jobs/P-13629?skillSet=&part=TECHNOLOGY&company=KAKAO&keyword=&employeeType=&page=1)
- [ ]  채점 서버
    - [ ]  메모리 제한 c-groups로 가능할 것 같기도 함.. (cgexec)
        - sudo apt install cgroup-tools
        - sudo cgcreate -g memory:/my-cgroup
        sudo cgset -r memory.limit_in_bytes=256M /my-cgroup
    - [ ]  카프카 스프링 부트 더 자세히 공부해보기 [https://semtax.tistory.com/83](https://semtax.tistory.com/83)
    - [ ]  카프카로 연동 변경해보기
    - [ ]  카프카 연동 테스트 어떻게 하는지 알아보기
- [ ]  **리팩토링 중 채점서버나 메인서버에서 INDEX 적용할 만한 칼럼이 있는지 고민**

### 스터디 중 공부 내용

- TCP는 가상회선 방식이 맞는가????? ⇒ NO!
    - [https://networkengineering.stackexchange.com/questions/6307/does-tcp-use-virtual-circuit-model?newreg=9cb33bb036da4a2cb614491c4c5b5804](https://networkengineering.stackexchange.com/questions/6307/does-tcp-use-virtual-circuit-model?newreg=9cb33bb036da4a2cb614491c4c5b5804)
    - 모든 패킷이 1개의 경로로 간다고 보장해 주지 않는다!!!
    
    ### **TCP 연결이 가상 회로가 아닌 이유**
    
    TCP/IP는 완전히 패킷 교환 방식입니다. 가상 회로에 대한 조항이 없습니다. 이것이 VOIP를 트렁킹할 때 QoS와 같은 것이 종종 필요한 이유입니다(가상 회로에는 QoS 보장이 내장되어 있음). **모든 패킷이 동일하게 라우팅될 것이라는 보장은 없습니다. 동일한 순서로 들어오지 않을 수도 있습니다. (연결 지향 관점에서) 적시에 들어오지 않을 수도 있습니다.** 따라서 IP와 같은 패킷 교환 프로토콜 위에 가상 회로를 자체적으로 구축할 수는 없습니다.
    
    TCP는 다소 가깝고 사실 다소 불완전한 대체물로 작동할 수 있습니다. 가능한 한 많은 보장을 제공합니다. 이것이 TCP/IP에서 구현될 때 H.323이 프로토콜이 선호하는 가상 회로 대신 TCP 연결을 사용하는 이유입니다.
    
    하지만 TCP 연결은 여전히 가상회선 방식이 아닙니다. 두 노드 간의 모든 스위치에서 연결하는 동안 대역폭을 예약하지 않기 때문입니다.
    
    물론 TCP 연결은 단순한 데이터그램 이상입니다. 여기에는 라우팅 정보(UDP와 마찬가지로)가 포함되지만 다른 쪽에서 스트림을 순서대로 재구성하는 데 필요한 회계 정보도 포함됩니다.
    
    **그러나 어찌되었든 TCP와 UDP는 모두 데이터그램 프로토콜입니다.** 이들은 라우팅 정보가 포함된 데이터 패킷을 라우터로 보내는데, 회로가 제공하는 보장은 전혀 없습니다. TCP는 회계 정보를 추가하여 엔드포인트가 오류와 일련의 데이터를 순서대로 처리할 수 있도록 함으로써 회로가 제공하는 것의 엔드포인트에 대한 보장의 하위 집합을 제공하지만, 그것은 하위 집합일 뿐입니다. 데이터그램 프로토콜 중에서 TCP는 가상 회로에 가장 가까운 것이지만, 개념적으로나 운영적으로 여전히 매우 다릅니다.
    
    TCP는 IP를 네트워크 계층으로 사용합니다. IP 헤더에는 패킷이 어디에서 오는지(소스 IP)와 패킷이 어디로 가는지(대상 IP)에 대한 정보가 들어 있습니다. IP는 패킷을 대상에 전달하고 회로나 다른 것에는 신경 쓰지 않습니다. 순전히 패킷 기반 프로토콜입니다.
    
    TCP 자체는 연결 지향 프로토콜입니다. 가상 회로도 아닙니다. (대역폭을 예약하지 않으며 일정한 비트 전송률이나 지연 시간을 제공하거나 약속하지도 않습니다.)
    
    UDP는 연결 없는 프로토콜입니다. 파이어 앤 포겟(fire-and-forget) 방식입니다. 애플리케이션은 데이터가 도착했는지 확인해야 합니다. (그게 전혀 중요하지 않다면요).
    

## ✨내일 진행할 내용

평판조회 서류 제출

# 😜 Today’s Small Happiness

- 합격!
- 칸예도 성공!!

# 🧐 Let’s Think About It

# 🙀 Got Stuck..