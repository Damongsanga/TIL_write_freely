# TIL (Today I Learned)

# 2월 23일 금요일

# 😃 What I Learned

## 오늘 배운 내용

## Facade

[https://inpa.tistory.com/entry/GOF-💠-퍼사드Facade-패턴-제대로-배워보자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8D%BC%EC%82%AC%EB%93%9CFacade-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)

- 복잡한 라이브러리 클래스에 대해 사용하기 편하게 간편한 인터페이스를 구성하기 위한 구조 패턴
- 지금 공부한 내용을 읽기 좋도록 정리하는 것도 일종의 파사드이다!
- 건축물의 정면을 뜻하는데, 과거에는 건축물의 정면에 건축 의도가 들어나있기에 정면만 봐도 건물의 목적을 바로 알 수 있다는 데에서 유래되었다

- 언제 사용?
    - 시스템이 너무 복잡하여 간단한 인터페이스를 통해 복잡한 시스템을 접근하도록 하고 싶을 때
    - 시스템을 사용하는 외부의 결합도가 너무 높아 의존성을 낮추기 위해
    - 유지보수

- Tip
    - 퍼사드 객체는 캡슐화가 아닌 추상화에 가깝다
    - 1개의 객체만 필요함으로 싱글톤으로 구성하는 것이 좋다

- 장점
    - 하위 시스템 간의 의존관계를 감소시키고 한 곳으로 모을 수 있다
    - 하위 시스템의 복잡성에서 코드를 분리하여, 외부에서 시스템을 사용하기 쉬워짐
    - 클라이언트가 시스템의 코드를 몰라도 Facade 클래스만 이용하고 사용 가능
- 단점
    - facade가 앱의 모든 클래스에 결합된 god 객체가 될 염려가 있다
    - 의존성 자체를 피할 수는 없다. facade 자체가 서브 시스템에 대한 의존성을 가지고 있기 때문이다
- 근데 어떻게 의존성이 낮아진다는거야?
    - 내부 로직의 구조를 변경하거나 파라미터, 리턴값을 변경하는 경우 직접적으로 영향을 받아 수정이 어려운 경우가 많음. 그러나 이를 중간에 매개체 역할을 해주는 퍼사드 객체가 있어 실제 내부 로직이 변경되더라고 크게 상관이 없어질 수 있다.

### 오늘의 블로그

### [아이들 나라 구독 시스템을 통해 알아보는 의존성을 제어하기 위한 여러가지 노력들](https://i-nara.oopy.io/9b010bf6-5f3c-4a46-8a36-d33a62f73c8d)

1. **경계 인식하고 나누어 관리하기**
    - 변화의 시점, 일관성을 책임질 수 있는 작은 경계를 나누어 인식
    - 구독 서비스를 한다고 해도 아래와 같이 경계 나눌 수 있다
        - **subscription**
            - 유저는 상품 구독 가능
            - 구독중인 유저는 서비스 구독 상태에 따라서 서비스 이용 여부 결정
        - **billings**
            - 구독시 주기적으로 청구
            - 청구 실패시 n번 유예 기간
        - **payments**
            - 청구 발생 ⇒ 정기 결제 수행
    - 경계간의는 계약관계가 존재하며 이들은 public interface임으로 continuous integration 을 통해 지속적으로 기능을 보장해야 한다
2. **번역하기**
    - Context! : 12 + 1은? 13이요 (산술) 1이요 (시간)
    - Translation Layer
3. **facade 패턴을 통한 레거시 통합하기**
    - 데이터 통합 레이어 (facade)

## 스프링 트랜잭션, 트랜잭션 전파 속성

[https://maivve.tistory.com/337](https://maivve.tistory.com/337)

[https://mangkyu.tistory.com/269](https://mangkyu.tistory.com/269) ⇒ 그대로 참고하여 공부

- **물리 트랜잭션**
    - **실제 DB 적용 트랜잭션으로 커넥션을 통해 커밋이나 롤백하는 단위**
    - 트랜잭션은 커넥션이 시작될 때와 끝날 때 시작/종료
    - 즉 1개의 트랜잭션을 사용한다는 것은 하나의 커넥션 객체를 사용한다는 것 ⇒ 물리 트랜잭션
- **논리 트랜잭션**
    - **스프링이 트랜잭션 매니저로 트랜잭션을 처리하는 단위**
    - 그러나 전파 속성에 의해 외부, 내부 트랜잭션이 동일한 트랜잭션을 사용할 수 있으며, 스프링 입장에서는 트랜잭션 매니저를 통해 트랜잭션을 관리하는 곳이 2군데
    - 따라서 실제 DB 트랜잭션 (물리 트랜잭션)과 스프링이 관리하는 트랜잭션을 분리하기 위해 논리 트랜잭션 사용
    - 즉, 트랜잭션 전파가 없으면 논리 트랜잭션 x
- 원칙
    - 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션 커밋, 아니면 롤백

- **REQUIRES**
    - 새로운 (물리) 트랜잭션 생성하거나 기존 트랜잭션에 참여
- **REQUIRES_NEW**
    - 새로운 트랜잭션을 항상 생성. 기존에 있다면 기존 트랜잭션 보류시키고 새로운 트랜잭션 사용
    - DB 커넥션을 새로 사용하는 것임으로 주의
- **NESTED**
    - NESTED는 이미 진행중인 트랜잭션에 중첩(자식) 트랜잭션을 만드는 것으로, 독립적인 트랜잭션을 만드는 REQUIRES_NEW와 다르다.
    - **NESTED에 의한 중첩 트랜잭션은 부모 트랜잭션의 영향(커밋과 롤백)을 받지만, 중첩 트랜잭션이 외부에 영향을 주지는 않는다.**
    - 즉, 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋이 가능하지만 외부 트랜잭션이 롤백되면 중첩 트랜잭션은 함께 롤백되는 것이다.
    - NESTED는 JDBC의 savepoint 기능을 사용하는데, DB 드라이버가 이를 지원하는지 확인이 필요하며 **JPA에서 사용이 불가능하다.**

# 😜 Today’s Small Happiness

# 🧐 Let’s Think About It

# 🙀 Got Stuck..