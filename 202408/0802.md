# TIL (Today I Learned)

# 8월 2일 금요일

# 😃 What I Learned

## ✨오늘 진행한 내용

- [x]  알고리즘 1문제 (1시간 반)
- [x]  헬스장 (1시간)
- [x]  스터디 공부 & 자료 정리 ⇒ 트랜잭션 딥다이브 (아래 7장 내용 정리함, 1시간)
- [ ]  카카오 MySQL 관련
    - [ ]  포트폴리오 최신화 (진행중)
        - [ ]  분산락 내용은 최대한 뒤로 뺄 것 → 공격들어오기 좋을듯
        - [ ]  채점 서버 구현 내용 추가
        - [ ]  아키텍처 이미지 추가해야함 (에러 발생해서 안되는중)
- [x]  데이터 중심 어플리케이션 설계 7장 : 트랜잭션 완료 (2시간)
    - [ ]  ACID
        - [ ]  원자성 : Abortion
        - [ ]  일관성 : 실제로는 DB 책임이 아닌 어플리케이션 책임이다
        - [ ]  격리성 : 직렬성 격리는 현실적으로 불가능 (완화된 격리조건인 snapshot 격리로 대체)
        - [ ]  지속성 : 테이프 → 디스크/SSD → 복제, 그러나 완벽이란 없다
    
    - [ ]  완화된 격리 조건
        - [ ]  모든 동시성 이슈는 해결 못하나 일부 동시성 이슈는 해결할 수 있는 상태
    - [ ]  **Read Commmitted** : 더티 읽기, 쓰기 방지
        - [ ]  스냅숏 격리 : 읽는 쪽은 쓰는쪽 차단 X, 쓰는 쪽은 읽는 쪽 차단 X ⇒ **MVCC**
            - [ ]  만약 READ COMMITTED 만 구현한다면 객체마다 2개의 버전 (커밋 버전, 수정되었으나 커밋되지 않은 버전) 만 필요하다
            - [ ]  그러나 스냅숏 격리를 지원하는 경우 읽기 격리를 위해 질의마다 독립정인 스냅숏을 사용하고, 전체 트랜잭션에 대해 동일한 스냅숏 사용
            - [ ]  트랜잭션 ID가 증가함으로, 현재 트랜잭션이 시작한 후에 시작한 트랜잭션이 쓴 데이터는 무시됨, abort 된 데이터도 물론 무시됨
            - [ ]  즉, 스냅숏은 REPETABLE READ나 SERIALIZABLE에 사용된다고 생각하면 된다. (근데 Oracle은 READ COMMITTED 인데 MVCC 사용한다고 함. 다 그런 것은 아닌듯)
            - [ ]  **여기서 트랜잭션의 시작때 스냅숏이 생성되는지, 트랜잭션에서 첫 읽기 쿼리가 발생할 때 생성되는지는 구현에 차이로 보인다.**
                - [ ]  **MySQL은 트랜잭션에서 첫 읽기 쿼리가 발생할 때 스냅숏 생성**
                    - [ ]  MySQL은 언두로그에서 읽어옴으로, 스냅숏 생성 시점보다 후에 생성된 언두로그의 데이터는 읽어오지 않는 방식으로 구현된다. (보통은 트랜잭션 ID만으로 알 수 있을 것이다.)
                - [ ]  **PostgreSQL은 트랜잭션이 시작될 때 바로 스냅숏 생성**
    - [ ]  **REPETABLE READ** : 스냅숏 격리와 사실상 같음(?) → SQL 표준에 스냅숏 격리 개념이 없기 때문. 따라서 데이터베이스마다 의미가 가지가지임
    - [ ]  문제 상황
        - [ ]  더티 쓰기 → 두 트랜잭션이 같은 객체 갱신
        - [ ]  갱신 손실 → 두 트랜잭션이 같은 객체 갱신
        - [ ]  쓰기 스큐 → 두 트랜잭션이 일부 같은 객체들을 읽고, 다른 객체를 갱신 (갱신 손실의 일반화?)
            - [ ]  원자적 연산 무의미, 갱신손실 감지 X
            1. 회의실 예약 시스템
            2. 다중 플레이어 게임
            3. 사용자명 획득 (유일성 제약 조건으로 해결 가능)
            4. 이중 사용방지 (잔고 음수)
        - [ ]  팬텀 : 트랜잭션이 실행한 쓰기가 다른 트랜잭션의 검색조건을 바꾸는 경우
            1. SELECT
            2. 조건 만족 여부 판단 (값 비교, count, 존재여부 등)
            3. INSERT, UPDATE, DELETE
            
            여기서 만약 CUD가 SELECT 조건 판단에 영향을 준다면? 만약 INSERT로 인해 락을 걸 수도 없다면??
            
            MySQL은 범위 질의에서 갭락으로 방지함
            
            비슷하게 회의실 문제를 예약할 수 있는 시간을 특정 간격으로 나누어 미리 회의실을 만들고 SELECT에 해당하는 회의실을 Lock을 걸 수 있다 (SELECT FOR UPDATE)
            
    - [ ]  문제 해결 방안
        - [ ]  락 (비관적, 낙천적락)
        - [ ]  갱신 손실 방지 (MySQL은 구현 X)
        - [ ]  read-modify-write vs compare-and-set ( `UPDATE a WET content = ‘new’ WHERE id = 1234 AND content = ‘old’` ) → WHERE 절이 만약 오래된 스냅샷을 읽는다면 문제 발생
        - [ ]  복제된 경우 compare-and-set이나 Lock이 사용할 수 없게 됨 (최신 복사본이 1개라고 가정하기 때문)
        
    - [ ]  직렬성 (SERIALIZABLE) : 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 하나씩 직렬로 실행될 때와 같도록 보장. 완화된 격리조건과 반대!
        1. **트랜잭션 실제로 순차적으로 실행**
            - **단일 스레드 루프**에서 트랜잭션 실행이 가능하다는 결론 (2007년) : 대표적으로 레디스
                - 램 가격이 저렴해지면서 트랜잭션이 접근해야 할 모든 데이터를 메모리에 저장할 수 있음
                - OTLP 트랜잭션이 보통 짧고 읽기 쓰기의 갯수가 적은 것을 알게됨. 반대로 분석 질의는 오래걸리나 읽기 전용이라 SERIALIZABLE 대신 일관된 스냅숏을 사용할 수 있음
            - **스토어드 프로시저**
                - 상호작용하는 다중 구문 대신 트랜잭션 코드 전체를 DB에 제출하여 네트워크 IO를 최소화
                - 대표적으로 레디스의 Lua, 볼트DB의 Java, Groovy
            - 파티셔닝
                - 단일 CPU 코어 사용시 병목 현상 발생 가능
                - 여러 CPU 코어, 노드로 확장하기 위해 파티셔닝을 할 수 있지만 이로 인한 다중 파티션 트랜잭션은 오버헤드가 엄청나다
                - 이는 데이터 구조에 크게 의존하며, 키-값 데이터는 쉽게 될 수 있지만 인덱스가 포함된 데이터는 코디네이션이 많이 필요하다
            - 제한 조건
                1. 모든 트랜잭션은 작고 빨라야
                2. 활성화된 데이터셋이 가용 메모리보다 작아야
                3. 쓰기 처리량이 단일 CPU 코어 내에서 처리할 수 있을 정도로 작아야 (아니면 파티셔닝)
                4. 다중 파티셔닝 트랜잭션은 주의해서 사용
        2. **2단계 잠금 (2PL, two-phase Locking) [비관적 동시성 제어]**
            - **공유락, 배타락!**
            - 스냅숏 격리는 읽는쪽과 쓰는쪽은 서로를 막지 않지만, 2PL은 쓰기를 원하는 객체에 대해서는 읽기, 쓰기 모두 불가능하게 하고, 읽기를 원하는 객체에 대해서는 쓰기를 불가능하게 한다.
            - 교착상태 발생할 확률 높음. 성능 이슈 주의
            
            2.1 서술 잠금 (Predicate Lock, MySQL에서의 Gap Lock)
            
            - 특정 범위에 대해서 SELECT하게 되면 미래에 추가될 수 있는 팬텀 객체에 대해서도 서술잠금이 적용됨
            - 실제로는 index-range Lock, next-key Lock으로 구현
            - 범위 잠금을 사용하는데에 있어, 검색조건에 index가 걸어두는 것이 매우 좋다. ⇒ 오버헤드가 매우 낮아짐
            - index가 없으면 테이블 전체 공유잠금을 걸게 됨 (성능 나쁘나 안전)
        3. **직렬성 스냅숏 격리같은 낙관적 동시성 제어**
            - SSI (직렬성 스냅숏 격리) : 완전한 직렬성을 제공하지만 약간의 성능 손해, PostgreSQL, 분산데이터베이스에서 사용
            - **트랜잭션의 모든 읽기는 DB의 일관된 스냅숏을 보게 됨 + 직렬성 충돌 감지 + 어보트 트랜잭션 결정하는 알고리즘**
            - 단점
                - 경쟁 심화시 어보트할 트랜잭션 비율 증가
                - 시스템 최대처리량 접근시 재시도로 인한 부하
            - 장점
                - 예비 용량이 충분하다면 성능 오히려 좋아짐
                - 가환 원자적 연산을 통해 경쟁 줄일 수 있음 (카운터 증가시, 이를 같은 트랜잭션에서 다시 읽지 않는다면 충돌없이 증가 연산 적용 가능)
            - 오래된 MVCC 읽기 감지하기
                - 트랜잭션에서 커밋시 사이에 다른 트랜잭션에서 커밋한 적이 있다면 어보트되어야 한다.
                - ***왜 읽을 때 오래된 스냅샷 여부 확인하지 않고 커밋할 때까지 기다려서 어보트? : 다른 트랜잭션이 어보트될 수도 있는 것이고 만약 읽기전용 트랜잭션인 경우 쓰기 스큐의 위험이 없음***
        - [ ]  직렬성 스냅숏 격리 성능
            - 트랜잭션 동작 추적을 상세하게 할 수록 어보트되어야 할 트랜잭션을 정확하게 판별할 수 있으나, 기록 오버헤드가 심해짐
            - 덜 상세하게 하면 빠르나 지나치게 많은 트랜잭션이 어보트될 수 있음
            - 어떤 경우에는 다른 트랜잭션에서 덮어 쓴 정보를 트랜잭션이 읽어도 괜찮음
                - 이 만으로 실행결과가 직렬적이라고 증명할 수 있는 경우 존재
                - PostgreSql은 불필요한 어보트를 줄이기 위해 이 방법 사용 ⇒ **읽기 전용 트랜잭션에 대해서는 덮어쓴 데이터를 읽는 것을 허용**
            - 2PC에 비해 읽기 부하에 강하다
            - 순차실행에 비해 단일 CPU 코어 처리량에 제한되지 않는다
            - 그러나 어보트 비율은 SSI의 전체적 성능에 큰 영향을 미친다
                - 이로인해 트랜잭션의 길이는 매우 짧기를 요구한다
                - **그러나 오래실행되는 읽기 전용 트랜잭션은 괜찮다!**
                    - 따라서 `@Transactional(readOnly = true)`가 일반 `@Transactional`보다 성능이 더 좋다
                    - 이는 직렬성 스냅숏 격리(Serializable Snapshot Isolation, SSI)가 읽기 전용 트랜잭션에 대해 더 유리한 특성을 갖기 때문
    
    ### 그러나 아래와 같은 경우라면 phantom read가 발생할 수 있다고 한다
    
    [https://velog.io/@glencode/트랜잭션과-ACID-그리고-MySQL-InnoDB에서-Phantom-Read](https://velog.io/@glencode/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-ACID-%EA%B7%B8%EB%A6%AC%EA%B3%A0-MySQL-InnoDB%EC%97%90%EC%84%9C-Phantom-Read)
    
    자세한건 더 rdbms에 친해지고 나서..
    
    는 다른 트랜잭션에서 데이터를 추가한 후에 내 트랜잭션에서 “UPDATE”하는 경우이다.
    
    처음에 없던 데이터가 UPDATE 되기도하고, 이후에 SELECT하면 보이게 된다.
    
    아래는 [이 블로그](https://velog.io/@glencode/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-ACID-%EA%B7%B8%EB%A6%AC%EA%B3%A0-MySQL-InnoDB%EC%97%90%EC%84%9C-Phantom-Read) 의 설명이다.
    
    우선 InnoDB에서 `Phantom Read`를 막는 방법은 `언두 로그`, `트랜잭션 번호`를 사용하여 `Phantom Read`를 방지한다.
    
    A 트랜잭션을 시작하고, 데이터를 조회한다. A 트랜잭션 번호는 3이다.
    
    B 트랜잭션을 시작하고, 데이터를 추가하고 커밋한다. B 트랜잭션 번호는 4이다.
    
    그리고 다시 A 트랜잭션이 데이터를 조회할 때 언두 로그를 조회하는데, 언두 로그에 자신의 트랜잭션 번호보다 큰 트랜잭션 번호는 조회하지 않는다. (B 트랜잭션이 추가한 데이터는 트랜잭션 번호가 4번)
    
    따라서 `Phantom Read`가 발생하지 않는다.
    
    하지만 `UPDATE` 쿼리를 실행했을 때, `Phantom Read`가 발생하는 이유는 다음과 같다.
    
    1. `UPDATE` 쿼리는 쓰기 락이 걸린다.
    2. 이때 **언두 로그에 쓰기 락을 걸 수 없기 때문에** 테이블에 쓰기 락을 걸고, 데이터를 변경한다.
    3. **그리고 `UPDATE` 쿼리가 반영되며, 언두 로그에 자신의 트랜잭션 번호가 갱신된 데이터가 생긴다.**
    4. 그리고 `SELECT` 쿼리를 실행하면 언두 로그에 있는 데이터를 조회한다.
    5. 언두 로그에 있던 데이터의 트랜잭션 번호는 자신의 트랜잭션 번호이므로, `Phantom Read`가 발생한다.
    

### 공부

- [ ]  싱글톤의 단점
- [ ]  왜 스프링은 싱글톤으로 관리?

### 면접 끝나고 할 것

- [ ]  https://github.com/squad-b/work-assistant-api 코드 뜯어보는중
- [ ]  채점 서버
    - [ ]  메모리 제한 c-groups로 가능할 것 같기도 함.. (cgexec)
        - sudo apt install cgroup-tools
        - sudo cgcreate -g memory:/my-cgroup
        sudo cgset -r memory.limit_in_bytes=256M /my-cgroup
    - [ ]  카프카 스프링 부트 더 자세히 공부해보기 [https://semtax.tistory.com/83](https://semtax.tistory.com/83)
    - [ ]  카프카로 연동 변경해보기
    - [ ]  카프카 연동 테스트 어떻게 하는지 알아보기
- [ ]  **리팩토링 중 채점서버나 메인서버에서 INDEX 적용할 만한 칼럼이 있는지 고민**

## ✨내일 진행할 내용

- 내일은 펜타!

# 😜 Today’s Small Happiness

# 🧐 Let’s Think About It

# 🙀 Got Stuck..