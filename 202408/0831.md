# TIL (Today I Learned)

# 8월 31일 토요일

# 😃 What I Learned

## ✨오늘 진행한 내용

- [x]  일의 격 마무리
- [x]  헬스장
- [x]  Line ongoing
- [x]  Batch 코틀린 프로젝트 기반하여 코틀린 학습

## 오늘 배운 내용

### 확장함수, 확장 프로퍼티

: 확장함수는 스태틱이랑 관련이 있나? No!

- 클래스가 아닌 인스턴스를 기반으로 작동.
    - 즉 특정 클래스의 인스턴스가 있어야 그 인스턴스의 확장함수를 호출할 수 있음 ⇒ 스태틱과 다름
- 스태틱의 경우 companion object를 사용

- 예시
    - List의 last, max 메서드는 원래 자바에 없었는데? → 확장함수였던것!

- 적용 범위?
    
    **패키지 단위! : 확장 함수는 특정 클래스에 속하는 것이 아니라, 패키지 단위로 선언되고 다른 파일이나 클래스에서 접근**
    
    - 같은 패키지
        - mypackage라는 패키지 아래 utils.kt라는 파일에 확장함수들을 정의해둔다면 mypackage 내의 모든 코드에서 사용 가능
    - 다른 패키지
        - import 문 사용
    - 가시성 (private, protected, ..)
        - 일반적으로는 파일 수준에서 정의
        - 필요에 의해 public, private, internal 등의 가시성 수정자 사용
            - 여기서 `internal`이란?
                - 모듈단위의 가시성으로, 모듈은 코틀린에서 단일 컴파일 단위
                - 일반적으로 하나의 gradle, maven 프로젝트나 명령줄에서 컴파일된 단일 Kotlin/Java 파일 세트를 의미
                - 보통 라이브러리 내부에서 사용되나 외부에 공개할 필요가 없는 코드 보호를 위함
                - 큰 프로젝트에서 모듈간의 의존성을 관리하기 위해

- 언제 사용?
    
    언제 인스턴스가 아니라 확장 함수를 사용하는 것이 더 적합한가?
    
    **확장 함수와 인스턴스 메서드는 서로 다른 목적과 용도가 있음**
    
    ### 1. 클래스의 수정이 불가능하거나 권장되지 않을 때
    
    - **제3자 라이브러리의 클래스**: 외부 라이브러리에서 제공하는 클래스는 직접 수정할 수 없습니다.
    - **표준 라이브러리의 클래스**: 코틀린 또는 자바 표준 라이브러리 클래스는 변경할 수 없습니다.
    - **프로덕션 코드에서 위험을 줄이기 위해**: 이미 사용 중인 클래스를 수정하는 것은 예상치 못한 부작용을 일으킬 수 있으므로, 안정성을 유지하려면 기존 코드를 수정하지 않고 기능을 확장하는 것이 좋습니다.
    
    이런 경우 확장 함수를 사용하면 해당 클래스의 기능을 확장할 수 있으면서도 기존 코드를 건드리지 않으므로, **안전하고 간편하게 기능을 추가**할 수 있습니다.
    
    ```kotlin
    fun String.isValidEmail(): Boolean {
        return this.contains("@") && this.contains(".")
    }
    
    fun main() {
        val email = "example@domain.com"
        println(email.isValidEmail())  // 확장 함수로 추가한 기능 사용
    }
    ```
    
    ### 2. 클래스 내부의 모든 객체에 기능이 필요하지 않을 때
    
    클래스 내부의 모든 인스턴스에 새로운 메서드가 필요한 것이 아니라, 특정 상황에서만 그 기능이 필요하다면 확장 함수를 사용해도 됩니다. 클래스 자체를 복잡하게 만들지 않고 필요한 기능을 추가할 수 있습니다.
    
    예를 들어, `String` 클래스에 특정 문자열 패턴을 검사하는 기능이 자주 필요할 때, 그 기능이 항상 필요한 것이 아니라면 확장 함수로 간단히 추가할 수 있습니다. 이 경우 **클래스 자체를 무겁게 만들지 않고도** 원하는 기능을 사용할 수 있습니다.
    
    ### 3. 가독성 및 코드 재사용성 향상
    
    확장 함수는 가독성을 높이고 코드 재사용성을 향상시키는 데 매우 유용합니다. 예를 들어, 자주 사용되는 기능을 확장 함수로 만들어 놓으면, 마치 원래 클래스의 메서드처럼 사용할 수 있어 코드가 직관적이고 일관되게 보입니다.
    
    ```kotlin
    fun MutableList<Int>.swap(index1: Int, index2: Int) {
        val tmp = this[index1]
        this[index1] = this[index2]
        this[index2] = tmp
    }
    
    fun main() {
        val list = mutableListOf(1, 2, 3)
        list.swap(0, 2)
        println(list)  // [3, 2, 1] 출력
    }
    
    ```
    
    보통 자바는 스태틱 메서드로 별도의 유틸리티 클래스생성, 그러나 코틀린에서 **확장 함수로 정의하는 것이 더 깔끔**
    
    ### 4. 기존 메서드와 확장 함수가 동시에 필요할 때 (오버라이드 X)
    
    기존 클래스에 이미 비슷한 기능의 메서드가 있지만, 약간 다른 기능이 필요할 때 확장 함수를 사용하면 원래 기능을 변경하지 않고도 새로운 기능을 추가할 수 있습니다. 이를 통해 **기존 메서드를 보호하면서도 필요한 기능을 추가**할 수 있습니다.
    
    ### 5. Companion Object를 사용하기 싫을 때
    
    자바에서 static 메서드를 많이 사용하는 것처럼, 코틀린에서도 `companion object`를 사용하여 비슷한 역할을 할 수 있습니다. 하지만 `companion object`가 코드의 복잡성을 증가시키거나, 클래스와 강하게 결합되는 것이 싫다면, 확장 함수가 더 나은 선택이 될 수 있습니다. **확장 함수는 클래스 외부에 존재하지만 마치 그 클래스의 멤버인 것처럼 사용**할 수 있기 때문입니다.
    
    ### 6. Kotlin에서 DSL을 구현할 때
    
    코틀린은 DSL(Domain-Specific Language)을 만들기 좋은 언어이며, 이때 확장 함수는 핵심적인 역할을 합니다. 확장 함수는 코드의 가독성과 유연성을 높여, DSL 문법을 쉽게 구현할 수 있게 도와줍니다.
    
    ```kotlin
    fun buildString(builderAction: StringBuilder.() -> Unit): String {
        val sb = StringBuilder()
        sb.builderAction()
        return sb.toString()
    }
    
    fun main() {
        val myString = buildString {
            append("Hello, ")
            append("World!")
        }
        println(myString)  // Hello, World! 출력
    }
    
    ```
    
    위 코드에서 `StringBuilder`에 대한 확장 함수를 사용하여 문자열을 간결하게 빌드할 수 있습니다. 이처럼 확장 함수는 코틀린의 DSL을 구성하는 중요한 도구가 됩니다.
    
    ### DSL이란?
    
    특정 도메인의 문제를 해결하기 위한 특화된 언어 ⇒ SQL 쿼리, HTML 등
    
    반대로 전반적인 문제를 해결하기 위한 언어는 자바, 코틀린, 파이썬 등의 기본적인 언어가 있다. (GSL)
    
    이 부분은 잘 이해가 되지 않아서 나중에 다시 배워보는걸로
    

### 코틀린 중위 호출 (infix)

수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣다

아래 두 호출은 동일

```kotlin
1.to("one")
1 to "one" 
```

- 특징
    - 하나의 매개변수만 가져야 함
    - 멤버 함수, 확장함 수로 정의 가능
- 방법
    
    ```kotlin
    infix fun 클래스이름.함수이름(매개변수이름: 타입): 반환타입 {
        // 함수 내용
    }
    ```
    

### 구조 분해 선언

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)

val (number, name) = 1 to "one"
// to 함수에 의해 호출된 "one"이 other, 1이 this이다
```

**Holing**

- [ ]  ~~작성!!~~
- [ ]  ~~이력관리~~
    - [x]  ~~포트폴리오 최신화 (진행중)~~
        - [ ]  ~~분산락 내용은 최대한 뒤로 뺄 것 → 공격들어오기 좋을듯~~
        - [x]  ~~채점 서버 구현 내용 추가~~

### 당장 해보면 좋을 것

- 결제 플로우 이해
- 레거시 메인 프로젝트 이해
- 테크톡 자료 준비
    - MySQL 트랜잭션 관련해서?
- 코틀린 미리 공부

## ✨내일 진행할 내용

내일은 연습하고 대니 공연보러!

## ✨월요일에 진행할 내용

- [ ]  알림톡 현황화 공유
- [ ]  온보딩 프로세스 체크리스트 최신화 공유
- [ ]  Batch 코틀린 마저 학습

# 😜 Today’s Small Happiness

- 오랜만에 짧지만 집에서 빈둥빈둥

# 🧐 Let’s Think About It

# 🙀 Got Stuck..