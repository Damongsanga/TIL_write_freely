# TIL (Today I Learned)

# 8월 9일 금요일

# 😃 What I Learned

## ✨오늘 진행한 내용

- [x]  월급쟁이 부자들 첫날 준비
- [x]  데이터 중심 어플리케이션 설계 9강 : 일관성과 합의
    
    ### 선형성
    
    - 선형성 vs 직렬성
        - **선형성 : 개별 객체(레지스터)에 대한 최신성 보장**
            - **DB 복사본이 1개만 있는 것처럼 동작**
            - 직렬성을 포함한 개념
        - 직렬성 : 트랜잭션별로 순서대로 동작하도록 보장
        - 2PL은 선형성 & 직렬성 모두 구현. **직렬성 스냅숏격리는 선형성은 만족하지 않음**
    - 엄격한 정족수를 사용한 읽기 쓰기도 선형적으로 보이나 아닐 수 있음
        - *그림 9-5. 웹 서버와 이미지 크기 변경 모듈은 파일 저장소와 메세지 큐를 모두 써서 통신하므로 갱쟁 조건이 발생할 가능성이 열려 있다.*
    - CAP은 좋지 않은 판단기준?
        - P (분단 내성, Partition tolerance)는 불가능. 네트워크 분단을 현실적으로 막을 수 없다.
        - 따라서 C (일관성, Consistency) vs A (가용성, Availability) 둘 중 1개만 선택해야 하는데, 여기서 일관성이 결국 선형성을 포함
        - CAP라는 정의 자체에서 가용성이라는 단어가 명확하게 사용되지 않는다. 고가용성 시스템은 이 정의에 부합하는 가용성을 만족시키지 않는 경우가 많아, 이 표현 자체를 쓰지 않는 것을 권장한다고 책은 주장한다.
    - 선형성 & 순서화 & 합의
        - 순서화 : 인과성 보존 → 인과적 의존성 → 이벤트 순서를 보장 (인과적으로 일관적이라는 뜻)
        - 예시로 일관된 스냅숏 격리는 인과성에 대해 일관적이라는 뜻이다.
        - 선형성은 인과적 일관성보다 강하다
            - 선형성은 인과성을 내포하기에 선형적 시스템은 인과성도 올바르게 유지함
            - 다만 성능, 가용성에 해가 될 수 있음 (네트워크 지연 등으로 인한)
            - 절충을 통해 성능 손해 없이 인과적 일관성을 만족 시킬 수 있고, 연구 중
    - **복제 방법들[](https://www.devkuma.com/docs/data-intensive-application/9/#%EB%B3%B5%EC%A0%9C-%EB%B0%A9%EB%B2%95%EB%93%A4)**
        - 단일 리더 복제(선형적일 수 있음)
        - 합의 알고리즘(선형적)
        - 다중 리더 복제(비선형적)
        - 리더 없는 복제(아마도 비선형적)
    
    ### 순서화
    
    - 선형성 vs 인과성
        - 선형성 : 전체 순서
            - Database 1개처럼! 따라서 전체 동작에 대해 순서를 매길 수 있다
        - 인과성 : 부분 순서
            - 동시 실행이란 두 동작에 대해 인과가 없다는 뜻으로, 순서 또한 없다는 뜻이다.
    - 인과적 의존성이란 순서화!
        - 버전 벡터
        - 일련번호, 타임스탬프
        - 방법
            - 노드 갯수만큼 mod 연산
            - 물리 시계에서 얻은 타임스탬프 추가
            - 일련번호 블록 미리 할당 등
            - 위 방법 모두 일관적이지 않다는 문제
    - 이를 극복 위한 램포트 타임스탬프 (카운터, 노드 ID 조합)
    - 그러나 유일성 제약을 구현해야하는 경우는?
        - 연산 전체순서 뿐만 아니라 언제 그 순서가 발생되는지도 구체적으로 알아야 한다.
    - 순서화를 위한 전체순서 브로드캐스트 ⇒ 비동기
        - 메세지 순서 결정을 위함으로, 이를 바탕으로 선형성 저장소를 구현할 수 있긴 하다 (다만 쓰기만 보장되며, 읽기는 보장 안됨)
        - 전체 순서 브로드캐스트와 합의는 서로 크게 연관
        - 구현 방법
            - 데이터베이스 복제
            - 직렬성 트랜잭션
            - 로그
            - 펜싱토큰
    - 원자적 연산
        - 원자적 compare-and-set
        - 원자적 increment-and-get을 통한 단조 증가, kafka의 idx값 등
    
    ### 합의
    
    - 2PC
        - 데이터 쓰기 → 준비 → 커밋
        - Blocking 원자적 커밋 프로토콜 ⇒ 이를 극복 위해 3PC 구상하였으나 이는 기약없는 네트워크를 기반으로 함으로 실제로는 원자성을 만족하도록 구현할 수 없음(?)
            - 이는 완벽한 장애 감지기를 기약없는 네트워크에서 구현할 수 없기 때문
        - 코디네이터 장애??
            - 이 기간에 진행된 모든 트랜잭션은 의심스로운 상태가 됨 → 무한히 재요청해야함
            - 이 시점의 의심스러운 고아 트랜잭션은 수동으로 커밋/어보트 해야할 수도 있음
            - 의심스러운 상황에 있는 동안 계속 잠금은 유지된다
        - 준비가 완료되면 (모든 노드가 OK 사인을 보냈다면) 모든 노드가 커밋 될 때까지 무한히 요청할 수 밖에 없다…! (이 시기부터는 원복할 방법이 없음)
        - 코디네이터가 단일 장애지점이 될 확률이 높음, 장애 증폭 리스크
        - 성능 손해도 심함.. 분산 트랜잭션을 꼭 써야 하는지 고민해라!
    - XA 트랜잭션
        - 2PC 커밋을 구현하는 표준, 코디네이터가 XA API를 구현
    - 합의 알고리즘의 특징
        - 균일한 동의
        - 무결성
        - 유효성
        - 종료 ⇒ 내결함성의 아이디어 형식화 (2PC에서는 만족 X, 합의 시스템 모델은 죽은 노드는 돌아오지 않는다고 가정하기 때문에 2PC에서 코디네이터가 복구될 때까지 기다리는 방법은 내결함성을 구현한다고 볼 수 없다)
    - 리더가 아웃된다면?
        1. 기다림 (XA Transaction)
        2. 사람이 직접 새 노드 선택 → 수동장애 복구
        3. 자동적으로 새 리더 선택 → 합의 알고리즘
    - 주키퍼는 합의, 장애감지, 멤버십 서비스를 위탁받는 역할을 가진다.
    - 단일 리더? or Else?
        - 단일 리더 DBMS는 모든 쓰기마다 합의가 필요한 것이 아니지만, 리더십을 유지, 변경하는 경우에는 수동으로 진행하는 경우가 아니라면 필요하다!
        - 리더가 없거나 다중 리더 복제 시스템은 합의 알고리즘이 필요없다

## ✨블로그 글 작성

### [**[DBMS] 데이터 중심 어플리케이션 설계 7장 (트랜잭션) 요약**](https://velog.io/@damongsanga/DBMS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A4%91%EC%8B%AC-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%A4%EA%B3%84-7%EC%9E%A5-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%9A%94%EC%95%BD)

## ✨내일 진행할 내용

- [ ]  작성!!
- [ ]  이력관리
    - [ ]  포트폴리오 최신화 (진행중)
        - [ ]  분산락 내용은 최대한 뒤로 뺄 것 → 공격들어오기 좋을듯
        - [ ]  채점 서버 구현 내용 추가

# 😜 Today’s Small Happiness

- 내일은 원주 방문!

# 🧐 Let’s Think About It

# 🙀 Got Stuck..